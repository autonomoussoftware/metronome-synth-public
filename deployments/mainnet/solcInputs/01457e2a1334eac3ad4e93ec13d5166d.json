{
  "language": "Solidity",
  "sources": {
    "contracts/DebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./dependencies/openzeppelin/security/ReentrancyGuard.sol\";\nimport \"./access/Manageable.sol\";\nimport \"./storage/DebtTokenStorage.sol\";\nimport \"./lib/WadRayMath.sol\";\n\nerror SyntheticDoesNotExist();\nerror SyntheticIsInactive();\nerror DebtTokenInactive();\nerror NameIsNull();\nerror SymbolIsNull();\nerror PoolIsNull();\nerror SyntheticIsNull();\nerror AllowanceNotSupported();\nerror ApprovalNotSupported();\nerror AmountIsZero();\nerror NotEnoughCollateral();\nerror DebtLowerThanTheFloor();\nerror RemainingDebtIsLowerThanTheFloor();\nerror TransferNotSupported();\nerror BurnFromNullAddress();\nerror BurnAmountExceedsBalance();\nerror MintToNullAddress();\nerror SurpassMaxDebtSupply();\nerror NewValueIsSameAsCurrent();\n\n/**\n * @title Non-transferable token that represents users' debts\n */\ncontract DebtToken is ReentrancyGuard, Manageable, DebtTokenStorageV1 {\n    using WadRayMath for uint256;\n\n    uint256 public constant SECONDS_PER_YEAR = 365.25 days;\n    uint256 private constant HUNDRED_PERCENT = 1e18;\n\n    string public constant VERSION = \"1.0.0\";\n\n    /// @notice Emitted when synthetic's debt is repaid\n    event DebtRepaid(address indexed payer, address indexed account, uint256 amount, uint256 repaid, uint256 fee);\n\n    /// @notice Emitted when active flag is updated\n    event DebtTokenActiveUpdated(bool newActive);\n\n    /// @notice Emitted when interest rate is updated\n    event InterestRateUpdated(uint256 oldInterestRate, uint256 newInterestRate);\n\n    /// @notice Emitted when max total supply is updated\n    event MaxTotalSupplyUpdated(uint256 oldMaxTotalSupply, uint256 newMaxTotalSupply);\n\n    /// @notice Emitted when synthetic token is issued\n    event SyntheticTokenIssued(\n        address indexed account,\n        address indexed to,\n        uint256 amount,\n        uint256 issued,\n        uint256 fee\n    );\n\n    /**\n     * @dev Throws if sender can't burn\n     */\n    modifier onlyIfCanBurn() {\n        if (msg.sender != address(pool)) revert SenderIsNotPool();\n        _;\n    }\n\n    /**\n     * @dev Throws if synthetic token doesn't exist\n     */\n    modifier onlyIfSyntheticTokenExists() {\n        if (!pool.doesSyntheticTokenExist(syntheticToken)) revert SyntheticDoesNotExist();\n        _;\n    }\n\n    /**\n     * @dev Throws if synthetic token isn't enabled\n     */\n    modifier onlyIfSyntheticTokenIsActive() {\n        if (!syntheticToken.isActive()) revert SyntheticIsInactive();\n        if (!isActive) revert DebtTokenInactive();\n        _;\n    }\n\n    /**\n     * @notice Update reward contracts' states\n     * @dev Should be called before balance changes (i.e. mint/burn)\n     */\n    modifier updateRewardsBeforeMintOrBurn(address account_) {\n        IRewardsDistributor[] memory _rewardsDistributors = pool.getRewardsDistributors();\n        ISyntheticToken _syntheticToken = syntheticToken;\n        uint256 _length = _rewardsDistributors.length;\n        for (uint256 i; i < _length; ++i) {\n            _rewardsDistributors[i].updateBeforeMintOrBurn(_syntheticToken, account_);\n        }\n        _;\n    }\n\n    function initialize(\n        string calldata name_,\n        string calldata symbol_,\n        IPool pool_,\n        ISyntheticToken syntheticToken_,\n        uint256 interestRate_,\n        uint256 maxTotalSupply_\n    ) external initializer {\n        if (bytes(name_).length == 0) revert NameIsNull();\n        if (bytes(symbol_).length == 0) revert SymbolIsNull();\n        if (address(pool_) == address(0)) revert PoolIsNull();\n        if (address(syntheticToken_) == address(0)) revert SyntheticIsNull();\n\n        __ReentrancyGuard_init();\n        __Manageable_init(pool_);\n\n        name = name_;\n        symbol = symbol_;\n        decimals = syntheticToken_.decimals();\n        syntheticToken = syntheticToken_;\n        lastTimestampAccrued = block.timestamp;\n        debtIndex = 1e18;\n        interestRate = interestRate_;\n        maxTotalSupply = maxTotalSupply_;\n        isActive = true;\n    }\n\n    /**\n     * @notice Accrue interest over debt supply\n     */\n    function accrueInterest() public override {\n        (\n            uint256 _interestAmountAccrued,\n            uint256 _debtIndex,\n            uint256 _lastTimestampAccrued\n        ) = _calculateInterestAccrual();\n\n        if (block.timestamp == _lastTimestampAccrued) {\n            return;\n        }\n\n        lastTimestampAccrued = block.timestamp;\n\n        if (_interestAmountAccrued > 0) {\n            totalSupply_ += _interestAmountAccrued;\n            debtIndex = _debtIndex;\n            // Note: We could save gas by having an accumulator and a function to mint accumulated fee\n            syntheticToken.mint(pool.feeCollector(), _interestAmountAccrued);\n        }\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(\n        address, /*owner_*/\n        address /*spender_*/\n    ) external pure override returns (uint256) {\n        revert AllowanceNotSupported();\n    }\n\n    /// @inheritdoc IERC20\n    // solhint-disable-next-line\n    function approve(\n        address, /*spender_*/\n        uint256 /*amount_*/\n    ) external override returns (bool) {\n        revert ApprovalNotSupported();\n    }\n\n    /**\n     * @notice Get the updated (principal + interest) user's debt\n     */\n    function balanceOf(address account_) public view override returns (uint256) {\n        uint256 _principal = principalOf[account_];\n        if (_principal == 0) {\n            return 0;\n        }\n\n        (, uint256 _debtIndex, ) = _calculateInterestAccrual();\n\n        // Note: The `debtIndex / debtIndexOf` gives the interest to apply to the principal amount\n        return (_principal * _debtIndex) / debtIndexOf[account_];\n    }\n\n    /**\n     * @notice Burn debt token\n     * @param from_ The account to burn from\n     * @param amount_ The amount to burn\n     */\n    function burn(address from_, uint256 amount_) external override onlyIfCanBurn {\n        _burn(from_, amount_);\n    }\n\n    /**\n     * @notice Lock collateral and mint synthetic token\n     * @param amount_ The amount to mint\n     * @param to_ The beneficiary account\n     * @return _issued The amount issued after fees\n     * @return _fee The fee amount collected\n     */\n    function issue(uint256 amount_, address to_)\n        external\n        override\n        whenNotShutdown\n        nonReentrant\n        onlyIfSyntheticTokenExists\n        onlyIfSyntheticTokenIsActive\n        returns (uint256 _issued, uint256 _fee)\n    {\n        if (amount_ == 0) revert AmountIsZero();\n\n        accrueInterest();\n\n        IPool _pool = pool;\n        ISyntheticToken _syntheticToken = syntheticToken;\n\n        (, , , , uint256 _issuableInUsd) = _pool.debtPositionOf(msg.sender);\n\n        IMasterOracle _masterOracle = _pool.masterOracle();\n\n        if (amount_ > _masterOracle.quoteUsdToToken(address(syntheticToken), _issuableInUsd)) {\n            revert NotEnoughCollateral();\n        }\n\n        uint256 _debtFloorInUsd = _pool.debtFloorInUsd();\n\n        if (\n            _debtFloorInUsd > 0 &&\n            _masterOracle.quoteTokenToUsd(address(syntheticToken), balanceOf(msg.sender) + amount_) < _debtFloorInUsd\n        ) {\n            revert DebtLowerThanTheFloor();\n        }\n\n        (_issued, _fee) = quoteIssueOut(amount_);\n        if (_fee > 0) {\n            _syntheticToken.mint(_pool.feeCollector(), _fee);\n        }\n\n        _syntheticToken.mint(to_, _issued);\n        _mint(msg.sender, amount_);\n\n        emit SyntheticTokenIssued(msg.sender, to_, amount_, _issued, _fee);\n    }\n\n    /**\n     * @notice Return interest rate (in percent) per second\n     */\n    function interestRatePerSecond() public view override returns (uint256) {\n        return interestRate / SECONDS_PER_YEAR;\n    }\n\n    /**\n     * @notice Quote gross `_amount` to issue `amountToIssue_` synthetic tokens\n     * @param amountToIssue_ Synth to issue\n     * @return _amount Gross amount\n     * @return _fee The fee amount to collect\n     */\n    function quoteIssueIn(uint256 amountToIssue_) external view override returns (uint256 _amount, uint256 _fee) {\n        uint256 _issueFee = pool.issueFee();\n        if (_issueFee == 0) {\n            return (amountToIssue_, _fee);\n        }\n\n        _amount = amountToIssue_.wadDiv(HUNDRED_PERCENT - _issueFee);\n        _fee = _amount - amountToIssue_;\n    }\n\n    /**\n     * @notice Quote synthetic tokens `_amountToIssue` by using gross `_amount`\n     * @param amount_ Gross amount\n     * @return _amountToIssue Synth to issue\n     * @return _fee The fee amount to collect\n     */\n    function quoteIssueOut(uint256 amount_) public view override returns (uint256 _amountToIssue, uint256 _fee) {\n        uint256 _issueFee = pool.issueFee();\n        if (_issueFee == 0) {\n            return (amount_, _fee);\n        }\n\n        _fee = amount_.wadMul(_issueFee);\n        _amountToIssue = amount_ - _fee;\n    }\n\n    /**\n     * @notice Quote synthetic token `_amount` need to repay `amountToRepay_` debt\n     * @param amountToRepay_ Debt amount to repay\n     * @return _amount Gross amount\n     * @return _fee The fee amount to collect\n     */\n    function quoteRepayIn(uint256 amountToRepay_) public view override returns (uint256 _amount, uint256 _fee) {\n        uint256 _repayFee = pool.repayFee();\n        if (_repayFee == 0) {\n            return (amountToRepay_, _fee);\n        }\n\n        _fee = amountToRepay_.wadMul(_repayFee);\n        _amount = amountToRepay_ + _fee;\n    }\n\n    /**\n     * @notice Quote debt `_amountToRepay` by burning `_amount` synthetic tokens\n     * @param amount_ Gross amount\n     * @return _amountToRepay Debt amount to repay\n     * @return _fee The fee amount to collect\n     */\n    function quoteRepayOut(uint256 amount_) public view override returns (uint256 _amountToRepay, uint256 _fee) {\n        uint256 _repayFee = pool.repayFee();\n        if (_repayFee == 0) {\n            return (amount_, _fee);\n        }\n\n        _amountToRepay = amount_.wadDiv(HUNDRED_PERCENT + _repayFee);\n        _fee = amount_ - _amountToRepay;\n    }\n\n    /**\n     * @notice Send synthetic token to decrease debt\n     * @dev The msg.sender is the payer and the account beneficed\n     * @param onBehalfOf_ The account that will have debt decreased\n     * @param amount_ The amount of synthetic token to burn (this is the gross amount, the repay fee will be subtracted from it)\n     * @return _repaid The amount repaid after fees\n     */\n    function repay(address onBehalfOf_, uint256 amount_)\n        external\n        override\n        whenNotShutdown\n        nonReentrant\n        returns (uint256 _repaid, uint256 _fee)\n    {\n        if (amount_ == 0) revert AmountIsZero();\n\n        accrueInterest();\n\n        IPool _pool = pool;\n        ISyntheticToken _syntheticToken = syntheticToken;\n\n        (_repaid, _fee) = quoteRepayOut(amount_);\n        if (_fee > 0) {\n            _syntheticToken.seize(msg.sender, _pool.feeCollector(), _fee);\n        }\n\n        uint256 _debtFloorInUsd = _pool.debtFloorInUsd();\n        if (_debtFloorInUsd > 0) {\n            uint256 _newDebtInUsd = _pool.masterOracle().quoteTokenToUsd(\n                address(_syntheticToken),\n                balanceOf(onBehalfOf_) - _repaid\n            );\n            if (_newDebtInUsd > 0 && _newDebtInUsd < _debtFloorInUsd) {\n                revert RemainingDebtIsLowerThanTheFloor();\n            }\n        }\n\n        _syntheticToken.burn(msg.sender, _repaid);\n        _burn(onBehalfOf_, _repaid);\n\n        emit DebtRepaid(msg.sender, onBehalfOf_, amount_, _repaid, _fee);\n    }\n\n    /**\n     * @notice Send synthetic token to decrease debt\n     * @dev This function helps users to no leave debt dust behind\n     * @param onBehalfOf_ The account that will have debt decreased\n     * @return _repaid The amount repaid after fees\n     * @return _fee The fee amount collected\n     */\n    function repayAll(address onBehalfOf_)\n        external\n        override\n        whenNotShutdown\n        nonReentrant\n        returns (uint256 _repaid, uint256 _fee)\n    {\n        accrueInterest();\n\n        _repaid = balanceOf(onBehalfOf_);\n        if (_repaid == 0) revert AmountIsZero();\n\n        ISyntheticToken _syntheticToken = syntheticToken;\n\n        uint256 _amount;\n        (_amount, _fee) = quoteRepayIn(_repaid);\n\n        if (_fee > 0) {\n            _syntheticToken.seize(msg.sender, pool.feeCollector(), _fee);\n        }\n\n        _syntheticToken.burn(msg.sender, _repaid);\n        _burn(onBehalfOf_, _repaid);\n\n        emit DebtRepaid(msg.sender, onBehalfOf_, _amount, _repaid, _fee);\n    }\n\n    /**\n     * @notice Return the total supply\n     */\n    function totalSupply() external view override returns (uint256) {\n        (uint256 _interestAmountAccrued, , ) = _calculateInterestAccrual();\n        return totalSupply_ + _interestAmountAccrued;\n    }\n\n    /// @inheritdoc IERC20\n    // solhint-disable-next-line\n    function transfer(\n        address, /*recipient_*/\n        uint256 /*amount_*/\n    ) external override returns (bool) {\n        revert TransferNotSupported();\n    }\n\n    /// @inheritdoc IERC20\n    // solhint-disable-next-line\n    function transferFrom(\n        address, /*sender_*/\n        address, /*recipient_*/\n        uint256 /*amount_*/\n    ) external override returns (bool) {\n        revert TransferNotSupported();\n    }\n\n    /**\n     * @notice Add this token to the debt tokens list if the recipient is receiving it for the 1st time\n     */\n    function _addToDebtTokensOfRecipientIfNeeded(address recipient_, uint256 recipientBalanceBefore_) private {\n        if (recipientBalanceBefore_ == 0) {\n            pool.addToDebtTokensOfAccount(recipient_);\n        }\n    }\n\n    /**\n     * @notice Destroy `amount` tokens from `account`, reducing the\n     * total supply\n     */\n    function _burn(address account_, uint256 amount_) private updateRewardsBeforeMintOrBurn(account_) {\n        if (account_ == address(0)) revert BurnFromNullAddress();\n\n        uint256 _accountBalance = balanceOf(account_);\n        if (_accountBalance < amount_) revert BurnAmountExceedsBalance();\n\n        unchecked {\n            principalOf[account_] = _accountBalance - amount_;\n            debtIndexOf[account_] = debtIndex;\n            totalSupply_ -= amount_;\n        }\n\n        emit Transfer(account_, address(0), amount_);\n\n        _removeFromDebtTokensOfSenderIfNeeded(account_, balanceOf(account_));\n    }\n\n    /**\n     * @notice Calculate interest to accrue\n     * @dev This util function avoids code duplication across `balanceOf` and `accrueInterest`\n     * @return _interestAmountAccrued The total amount of debt tokens accrued\n     * @return _debtIndex The new `debtIndex` value\n     */\n    function _calculateInterestAccrual()\n        private\n        view\n        returns (\n            uint256 _interestAmountAccrued,\n            uint256 _debtIndex,\n            uint256 _lastTimestampAccrued\n        )\n    {\n        _lastTimestampAccrued = lastTimestampAccrued;\n        _debtIndex = debtIndex;\n\n        if (block.timestamp > _lastTimestampAccrued) {\n            uint256 _interestRateToAccrue = interestRatePerSecond() * (block.timestamp - _lastTimestampAccrued);\n            if (_interestRateToAccrue > 0) {\n                _interestAmountAccrued = _interestRateToAccrue.wadMul(totalSupply_);\n                _debtIndex += _interestRateToAccrue.wadMul(debtIndex);\n            }\n        }\n    }\n\n    /**\n     * @notice Create `amount` tokens and assigns them to `account`, increasing\n     * the total supply\n     */\n    function _mint(address account_, uint256 amount_) private updateRewardsBeforeMintOrBurn(account_) {\n        if (account_ == address(0)) revert MintToNullAddress();\n\n        uint256 _balanceBefore = balanceOf(account_);\n\n        totalSupply_ += amount_;\n        if (totalSupply_ > maxTotalSupply) revert SurpassMaxDebtSupply();\n\n        principalOf[account_] = _balanceBefore + amount_;\n        debtIndexOf[account_] = debtIndex;\n        emit Transfer(address(0), account_, amount_);\n\n        _addToDebtTokensOfRecipientIfNeeded(account_, _balanceBefore);\n    }\n\n    /**\n     * @notice Remove this token to the debt tokens list if the sender's balance goes to zero\n     */\n    function _removeFromDebtTokensOfSenderIfNeeded(address sender_, uint256 senderBalanceAfter_) private {\n        if (senderBalanceAfter_ == 0) {\n            pool.removeFromDebtTokensOfAccount(sender_);\n        }\n    }\n\n    /**\n     * @notice Update max total supply\n     */\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external override onlyGovernor {\n        uint256 _currentMaxTotalSupply = maxTotalSupply;\n        if (newMaxTotalSupply_ == _currentMaxTotalSupply) revert NewValueIsSameAsCurrent();\n        emit MaxTotalSupplyUpdated(_currentMaxTotalSupply, newMaxTotalSupply_);\n        maxTotalSupply = newMaxTotalSupply_;\n    }\n\n    /**\n     * @notice Update interest rate (APR)\n     */\n    function updateInterestRate(uint256 newInterestRate_) external override onlyGovernor {\n        accrueInterest();\n        uint256 _currentInterestRate = interestRate;\n        if (newInterestRate_ == _currentInterestRate) revert NewValueIsSameAsCurrent();\n        emit InterestRateUpdated(_currentInterestRate, newInterestRate_);\n        interestRate = newInterestRate_;\n    }\n\n    /**\n     * @notice Enable/Disable the Debt Token\n     */\n    function toggleIsActive() external override onlyGovernor {\n        bool _newIsActive = !isActive;\n        emit DebtTokenActiveUpdated(_newIsActive);\n        isActive = _newIsActive;\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/access/Manageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/proxy/utils/Initializable.sol\";\nimport \"../utils/TokenHolder.sol\";\nimport \"../interfaces/IGovernable.sol\";\nimport \"../interfaces/IManageable.sol\";\n\nerror SenderIsNotPool();\nerror SenderIsNotGovernor();\nerror IsPaused();\nerror IsShutdown();\nerror PoolAddressIsNull();\n\n/**\n * @title Reusable contract that handles accesses\n */\nabstract contract Manageable is IManageable, TokenHolder, Initializable {\n    /**\n     * @notice Pool contract\n     */\n    IPool public pool;\n\n    /**\n     * @dev Throws if `msg.sender` isn't the pool\n     */\n    modifier onlyPool() {\n        if (msg.sender != address(pool)) revert SenderIsNotPool();\n        _;\n    }\n\n    /**\n     * @dev Throws if `msg.sender` isn't the governor\n     */\n    modifier onlyGovernor() {\n        if (msg.sender != governor()) revert SenderIsNotGovernor();\n        _;\n    }\n\n    /**\n     * @dev Throws if contract is paused\n     */\n    modifier whenNotPaused() {\n        if (pool.paused()) revert IsPaused();\n        _;\n    }\n\n    /**\n     * @dev Throws if contract is shutdown\n     */\n    modifier whenNotShutdown() {\n        if (pool.everythingStopped()) revert IsShutdown();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __Manageable_init(IPool pool_) internal initializer {\n        if (address(pool_) == address(0)) revert PoolAddressIsNull();\n        pool = pool_;\n    }\n\n    /**\n     * @notice Get the governor\n     * @return _governor The governor\n     */\n    function governor() public view returns (address _governor) {\n        _governor = IGovernable(address(pool)).governor();\n    }\n\n    /// @inheritdoc TokenHolder\n    function _requireCanSweep() internal view override onlyGovernor {}\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/storage/DebtTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IDebtToken.sol\";\n\nabstract contract DebtTokenStorageV1 is IDebtToken {\n    /**\n     * @notice The name of the token\n     */\n    string public override name;\n\n    /**\n     * @notice The symbol of the token\n     */\n    string public override symbol;\n\n    /**\n     * @notice The mapping of the users' minted tokens\n     * @dev This value changes within the mint and burn operations\n     */\n    mapping(address => uint256) internal principalOf;\n\n    /**\n     * @notice The `debtIndex` \"snapshot\" of the account's latest `principalOf` update (i.e. mint/burn)\n     */\n    mapping(address => uint256) internal debtIndexOf;\n\n    /**\n     * @notice The supply cap\n     */\n    uint256 public override maxTotalSupply;\n\n    /**\n     * @notice The total amount of minted tokens\n     */\n    uint256 internal totalSupply_;\n\n    /**\n     * @notice The timestamp when interest accrual was calculated for the last time\n     */\n    uint256 public override lastTimestampAccrued;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the beginning\n     */\n    uint256 public override debtIndex;\n\n    /**\n     * @notice Interest rate\n     * @dev Use 0.1e18 for 10% APR\n     */\n    uint256 public override interestRate;\n\n    /**\n     * @notice The Synthetic token\n     */\n    ISyntheticToken public override syntheticToken;\n\n    /**\n     * @notice If true, disables msAsset minting on this pool\n     */\n    bool public override isActive;\n\n    /**\n     * @notice The decimals of the token\n     */\n    uint8 public override decimals;\n}\n"
    },
    "contracts/lib/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title Math library\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n * @dev Based on https://github.com/dapphub/ds-math/blob/master/src/math.sol\n */\nlibrary WadRayMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @param a Wad\n     * @param b Wad\n     * @return The result of a*b, in wad\n     */\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n\n        return (a * b + HALF_WAD) / WAD;\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @param a Wad\n     * @param b Wad\n     * @return The result of a/b, in wad\n     */\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * WAD + b / 2) / b;\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/utils/TokenHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nerror FallbackIsNotAllowed();\nerror ReceiveIsNotAllowed();\n\n/**\n * @title Utils contract that handles tokens sent to it\n */\nabstract contract TokenHolder {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Revert fallback calls\n     */\n    fallback() external payable {\n        revert FallbackIsNotAllowed();\n    }\n\n    /**\n     * @dev Revert when receiving by default\n     */\n    receive() external payable virtual {\n        revert ReceiveIsNotAllowed();\n    }\n\n    /**\n     * @notice ERC20 recovery in case of stuck tokens due direct transfers to the contract address.\n     * @param token_ The token to transfer\n     * @param to_ The recipient of the transfer\n     * @param amount_ The amount to send\n     */\n    function sweep(\n        IERC20 token_,\n        address to_,\n        uint256 amount_\n    ) external {\n        _requireCanSweep();\n\n        if (address(token_) == address(0)) {\n            Address.sendValue(payable(to_), amount_);\n        } else {\n            token_.safeTransfer(to_, amount_);\n        }\n    }\n\n    /**\n     * @notice Function that reverts if the caller isn't allowed to sweep tokens\n     * @dev Usually requires the owner or governor as the caller\n     */\n    function _requireCanSweep() internal view virtual;\n}\n"
    },
    "contracts/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @notice Governable interface\n */\ninterface IGovernable {\n    function governor() external view returns (address _governor);\n\n    function transferGovernorship(address _proposedGovernor) external;\n}\n"
    },
    "contracts/interfaces/IManageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPool.sol\";\n\n/**\n * @notice Manageable interface\n */\ninterface IManageable {\n    function pool() external view returns (IPool _pool);\n}\n"
    },
    "contracts/dependencies/openzeppelin/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/dependencies/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IDepositToken.sol\";\nimport \"./IDebtToken.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IRewardsDistributor.sol\";\nimport \"./IPoolRegistry.sol\";\n\n/**\n * @notice Pool interface\n */\ninterface IPool is IPauseable, IGovernable {\n    function debtFloorInUsd() external view returns (uint256);\n\n    function depositFee() external view returns (uint256);\n\n    function issueFee() external view returns (uint256);\n\n    function withdrawFee() external view returns (uint256);\n\n    function repayFee() external view returns (uint256);\n\n    function swapFee() external view returns (uint256);\n\n    function liquidationFees() external view returns (uint128 liquidatorIncentive, uint128 protocolFee);\n\n    function feeCollector() external view returns (address);\n\n    function maxLiquidable() external view returns (uint256);\n\n    function doesSyntheticTokenExist(ISyntheticToken syntheticToken_) external view returns (bool);\n\n    function doesDebtTokenExist(IDebtToken debtToken_) external view returns (bool);\n\n    function doesDepositTokenExist(IDepositToken depositToken_) external view returns (bool);\n\n    function depositTokenOf(IERC20 underlying_) external view returns (IDepositToken);\n\n    function debtTokenOf(ISyntheticToken syntheticToken_) external view returns (IDebtToken);\n\n    function getDepositTokens() external view returns (address[] memory);\n\n    function getDebtTokens() external view returns (address[] memory);\n\n    function getRewardsDistributors() external view returns (IRewardsDistributor[] memory);\n\n    function debtOf(address account_) external view returns (uint256 _debtInUsd);\n\n    function depositOf(address account_) external view returns (uint256 _depositInUsd, uint256 _issuableLimitInUsd);\n\n    function debtPositionOf(address account_)\n        external\n        view\n        returns (\n            bool _isHealthy,\n            uint256 _depositInUsd,\n            uint256 _debtInUsd,\n            uint256 _issuableLimitInUsd,\n            uint256 _issuableInUsd\n        );\n\n    function addDebtToken(IDebtToken debtToken_) external;\n\n    function removeDebtToken(IDebtToken debtToken_) external;\n\n    function addDepositToken(address depositToken_) external;\n\n    function removeDepositToken(IDepositToken depositToken_) external;\n\n    function liquidate(\n        ISyntheticToken syntheticToken_,\n        address account_,\n        uint256 amountToRepay_,\n        IDepositToken depositToken_\n    )\n        external\n        returns (\n            uint256 _totalSeized,\n            uint256 _toLiquidator,\n            uint256 _fee\n        );\n\n    function quoteLiquidateIn(\n        ISyntheticToken syntheticToken_,\n        uint256 totalToSeized_,\n        IDepositToken depositToken_\n    )\n        external\n        view\n        returns (\n            uint256 _amountToRepay,\n            uint256 _toLiquidator,\n            uint256 _fee\n        );\n\n    function quoteLiquidateMax(\n        ISyntheticToken syntheticToken_,\n        address account_,\n        IDepositToken depositToken_\n    ) external view returns (uint256 _maxAmountToRepay);\n\n    function quoteLiquidateOut(\n        ISyntheticToken syntheticToken_,\n        uint256 amountToRepay_,\n        IDepositToken depositToken_\n    )\n        external\n        view\n        returns (\n            uint256 _totalSeized,\n            uint256 _toLiquidator,\n            uint256 _fee\n        );\n\n    function quoteSwapIn(\n        ISyntheticToken syntheticTokenIn_,\n        ISyntheticToken syntheticTokenOut_,\n        uint256 amountOut_\n    ) external view returns (uint256 _amountIn, uint256 _fee);\n\n    function quoteSwapOut(\n        ISyntheticToken syntheticTokenIn_,\n        ISyntheticToken syntheticTokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _fee);\n\n    function swap(\n        ISyntheticToken syntheticTokenIn_,\n        ISyntheticToken syntheticTokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, uint256 _fee);\n\n    function updateSwapFee(uint256 newSwapFee_) external;\n\n    function updateDebtFloor(uint256 newDebtFloorInUsd_) external;\n\n    function updateDepositFee(uint256 newDepositFee_) external;\n\n    function updateIssueFee(uint256 newIssueFee_) external;\n\n    function updateWithdrawFee(uint256 newWithdrawFee_) external;\n\n    function updateRepayFee(uint256 newRepayFee_) external;\n\n    function updateLiquidatorIncentive(uint128 newLiquidatorIncentive_) external;\n\n    function updateProtocolLiquidationFee(uint128 newProtocolLiquidationFee_) external;\n\n    function updateMaxLiquidable(uint256 newMaxLiquidable_) external;\n\n    function updateTreasury(ITreasury newTreasury_) external;\n\n    function treasury() external view returns (ITreasury);\n\n    function masterOracle() external view returns (IMasterOracle);\n\n    function poolRegistry() external view returns (IPoolRegistry);\n\n    function addToDepositTokensOfAccount(address account_) external;\n\n    function removeFromDepositTokensOfAccount(address account_) external;\n\n    function addToDebtTokensOfAccount(address account_) external;\n\n    function removeFromDebtTokensOfAccount(address account_) external;\n\n    function getDepositTokensOfAccount(address account_) external view returns (address[] memory);\n\n    function getDebtTokensOfAccount(address account_) external view returns (address[] memory);\n\n    function addRewardsDistributor(IRewardsDistributor distributor_) external;\n\n    function removeRewardsDistributor(IRewardsDistributor distributor_) external;\n\n    function toggleIsSwapActive() external;\n\n    function isSwapActive() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IDepositToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IDepositToken is IERC20Metadata {\n    function underlying() external view returns (IERC20);\n\n    function collateralFactor() external view returns (uint256);\n\n    function unlockedBalanceOf(address account_) external view returns (uint256);\n\n    function lockedBalanceOf(address account_) external view returns (uint256);\n\n    function deposit(uint256 amount_, address onBehalfOf_) external returns (uint256 _deposited, uint256 _fee);\n\n    function quoteDepositIn(uint256 amountToDeposit_) external view returns (uint256 _amount, uint256 _fee);\n\n    function quoteDepositOut(uint256 amount_) external view returns (uint256 _amountToDeposit, uint256 _fee);\n\n    function quoteWithdrawIn(uint256 amountToWithdraw_) external view returns (uint256 _amount, uint256 _fee);\n\n    function quoteWithdrawOut(uint256 amount_) external view returns (uint256 _amountToWithdraw, uint256 _fee);\n\n    function withdraw(uint256 amount_, address to_) external returns (uint256 _withdrawn, uint256 _fee);\n\n    function seize(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) external;\n\n    function updateCollateralFactor(uint128 newCollateralFactor_) external;\n\n    function isActive() external view returns (bool);\n\n    function toggleIsActive() external;\n\n    function maxTotalSupply() external view returns (uint256);\n\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external;\n}\n"
    },
    "contracts/interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ISyntheticToken.sol\";\n\ninterface IDebtToken is IERC20Metadata {\n    function lastTimestampAccrued() external view returns (uint256);\n\n    function isActive() external view returns (bool);\n\n    function syntheticToken() external view returns (ISyntheticToken);\n\n    function accrueInterest() external;\n\n    function debtIndex() external returns (uint256 debtIndex_);\n\n    function burn(address from_, uint256 amount_) external;\n\n    function issue(uint256 amount_, address to_) external returns (uint256 _issued, uint256 _fee);\n\n    function repay(address onBehalfOf_, uint256 amount_) external returns (uint256 _repaid, uint256 _fee);\n\n    function repayAll(address onBehalfOf_) external returns (uint256 _repaid, uint256 _fee);\n\n    function quoteIssueIn(uint256 amountToIssue_) external view returns (uint256 _amount, uint256 _fee);\n\n    function quoteIssueOut(uint256 amount_) external view returns (uint256 _amountToIssue, uint256 _fee);\n\n    function quoteRepayIn(uint256 amountToRepay_) external view returns (uint256 _amount, uint256 _fee);\n\n    function quoteRepayOut(uint256 amount_) external view returns (uint256 _amountToRepay, uint256 _fee);\n\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external;\n\n    function updateInterestRate(uint256 newInterestRate_) external;\n\n    function maxTotalSupply() external view returns (uint256);\n\n    function interestRate() external view returns (uint256);\n\n    function interestRatePerSecond() external view returns (uint256);\n\n    function toggleIsActive() external;\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITreasury {\n    function pull(address to_, uint256 amount_) external;\n\n    function migrateTo(address newTreasury_) external;\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Reward Distributor interface\n */\ninterface IRewardsDistributor {\n    function rewardToken() external view returns (IERC20);\n\n    function tokenSpeeds(IERC20 token_) external view returns (uint256);\n\n    function tokensAccruedOf(address account_) external view returns (uint256);\n\n    function updateBeforeMintOrBurn(IERC20 token_, address account_) external;\n\n    function updateBeforeTransfer(\n        IERC20 token_,\n        address from_,\n        address to_\n    ) external;\n\n    function claimable(address account_) external view returns (uint256 _claimable);\n\n    function claimable(address account_, IERC20 token_) external view returns (uint256 _claimable);\n\n    function claimRewards(address account_) external;\n\n    function claimRewards(address account_, IERC20[] memory tokens_) external;\n\n    function claimRewards(address[] memory accounts_, IERC20[] memory tokens_) external;\n\n    function updateTokenSpeed(IERC20 token_, uint256 newSpeed_) external;\n\n    function updateTokenSpeeds(IERC20[] calldata tokens_, uint256[] calldata speeds_) external;\n\n    function tokens(uint256) external view returns (IERC20);\n\n    function tokenStates(IERC20) external view returns (uint224 index, uint32 timestamp);\n\n    function accountIndexOf(IERC20, address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./external/IMasterOracle.sol\";\nimport \"./IPauseable.sol\";\nimport \"./IGovernable.sol\";\nimport \"./ISyntheticToken.sol\";\n\ninterface IPoolRegistry is IPauseable, IGovernable {\n    function isPoolRegistered(address pool_) external view returns (bool);\n\n    function feeCollector() external view returns (address);\n\n    function nativeTokenGateway() external view returns (address);\n\n    function getPools() external view returns (address[] memory);\n\n    function registerPool(address pool_) external;\n\n    function unregisterPool(address pool_) external;\n\n    function masterOracle() external view returns (IMasterOracle);\n\n    function updateMasterOracle(IMasterOracle newOracle_) external;\n\n    function updateFeeCollector(address newFeeCollector_) external;\n\n    function updateNativeTokenGateway(address newGateway_) external;\n\n    function idOfPool(address pool_) external view returns (uint256);\n\n    function nextPoolId() external view returns (uint256);\n}\n"
    },
    "contracts/dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/ISyntheticToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IDebtToken.sol\";\nimport \"./IPoolRegistry.sol\";\n\ninterface ISyntheticToken is IERC20Metadata {\n    function isActive() external view returns (bool);\n\n    function mint(address to_, uint256 amount_) external;\n\n    function burn(address from_, uint256 amount) external;\n\n    function poolRegistry() external returns (IPoolRegistry);\n\n    function toggleIsActive() external;\n\n    function seize(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) external;\n\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external;\n\n    function maxTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/IMasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IMasterOracle {\n    function quoteTokenToUsd(address _asset, uint256 _amount) external view returns (uint256 _amountInUsd);\n\n    function quoteUsdToToken(address _asset, uint256 _amountInUsd) external view returns (uint256 _amount);\n\n    function quote(\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn\n    ) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/interfaces/IPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPauseable {\n    function paused() external view returns (bool);\n\n    function everythingStopped() external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}